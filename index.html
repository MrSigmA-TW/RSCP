<!DOCTYPE html>
<html lang="zh-TW">
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™‚å½±é›™è¡Œ â€” Shadow of Mine</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1>ã€Šæ™‚å½±é›™è¡Œã€‹Shadow of Mine</h1>
            <p>åœ¨ä¸€åº§æ™‚ç©ºéŒ¯äº‚çš„åŸå¸‚ä¸­ï¼Œä½ æ˜¯å”¯ä¸€é‚„èƒ½ç©¿æ¢­éå»çš„å­˜åœ¨ã€‚é€éæ®˜å½±è£ç½®ï¼Œä½ å°‡èˆ‡ã€Œéå»çš„è‡ªå·±ã€ä¸¦è‚©åˆä½œï¼Œè§£é–‹éŒ¯ç¶œè¤‡é›œçš„è¬é¡Œï¼Œé‡å¡‘å‘½é‹çš„è„ˆçµ¡ã€‚é€™æ˜¯ä¸€æ¬¾èåˆæ©«å‘å·è»¸æ“ä½œèˆ‡æ™‚é–“åˆ†èº«ç­–ç•¥çš„æ²‰æµ¸å¼å¹³å°éŠæˆ²ã€‚</p>
            <p>æ¯ä¸€æ¬¡ç©¿è¶Šï¼Œéƒ½å°‡ç•™ä¸‹ä¸€æ®µå½±å­è¡Œå‹•ï¼›è€Œä½ ï¼Œå¿…é ˆèˆ‡é€™äº›æ®˜å½±åŒæ­¥è¡Œå‹•ã€äº’ç›¸é…åˆï¼Œæ‰èƒ½ç ´è§£æ©Ÿé—œã€æˆ°å‹æ•µäººï¼Œç”šè‡³æ”¹è®Šç„¡æ³•æŒ½å›çš„éå»ã€‚</p>
            <p>åœ¨ã€Œè¨˜æ†¶ã€èˆ‡ã€Œç¾å¯¦ã€äº¤éŒ¯çš„è·¯é€”ä¸­ï¼Œæ™‚é–“ä¸å†åªæ˜¯éå»èˆ‡æœªä¾†çš„ç•Œç·šï¼Œæ›´æ˜¯ä½ èˆ‡è‡ªå·±ä¹‹é–“æœ€æ·±çš„ç¾ˆçµ†ã€‚</p>
            <button class="start-button" onclick="startGame()">é–‹å§‹éŠæˆ²</button>
        </div>
    </div>
    <div id="gameContainer">
        <div id="gameHeader">
            <div id="ui">
                <div>é—œå¡é€²åº¦: <span id="level">1</span>/5</div>
                <div>ç•¶å‰å›åˆ: <span id="round">1</span></div>
                <div>å½±å­æ•¸é‡: <span id="echoCount">0</span>/5</div>
                <div>ç¸½æ™‚é–“: <span id="totalTimer">0</span>s</div>
            </div>
            <div class="game-controls">
                <div id="speedControl">
                    <button onclick="setSpeed('slow')" class="speed-btn">æ…¢é€Ÿ</button>
                    <button onclick="setSpeed('normal')" class="speed-btn">ä¸­é€Ÿ</button>
                    <button onclick="setSpeed('fast')" class="speed-btn">å¿«é€Ÿ</button>
                </div>
                <div id="musicControl">
                    <button onclick="toggleBGM()" id="bgmBtn">éŸ³æ¨‚ï¼šé—œ</button>
                    <button onclick="resetGame()" class="speed-btn">é‡ç½®éŠæˆ²</button>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŠæˆ²é…ç½®
        const MAX_ECHOES = 5;
        const ROUND_TIME_LIMIT = 20000; // æ”¹å›20ç§’
        
        // éŠæˆ²ç‹€æ…‹
        let gameState = {
            round: 1,
            level: 1,
            timer: 0,
            gameStartTime: Date.now(),
            roundStartTime: Date.now(),
            isRoundActive: true,
            goalReached: false,
            showingRoundInfo: false,
            levelStats: {
                1: { rounds: 0, startTime: Date.now() },
                2: { rounds: 0, startTime: 0 },
                3: { rounds: 0, startTime: 0 },
                4: { rounds: 0, startTime: 0 },
                5: { rounds: 0, startTime: 0 }
            }
        };
        
        // ç©å®¶å°è±¡
        const player = {
            x: 50,
            y: 400,
            width: 30,
            height: 30,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpPower: 15,
            onGround: false,
            color: '#e74c3c', // ç´…è‰²
            recording: [],
            isInvulnerable: false,
            invulnerableTimer: 0,
            wasJumping: false
        };

        // æ•µäººç³»çµ±
        class Enemy {
            constructor(x, y, width, height, speed, type = 'chaser') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.originalSpeed = speed;
                this.color = '#e74c3c';
                this.type = type; // 'chaser', 'patrol', 'dasher'

                // è·¯å¾‘é æ¸¬
                this.lastPlayerPos = { x: player.x, y: player.y };
                this.predictedPos = { x: player.x, y: player.y };
                this.predictionFrames = 0;

                // å·¡é‚æ¨¡å¼
                this.patrolPoints = [];
                this.currentPatrolIndex = 0;
                this.patrolDirection = 1;

                // è¡åˆºæ¨¡å¼
                this.dashCooldown = 0;
                this.dashDuration = 0;
                this.isDashing = false;
                this.dashDirection = { x: 0, y: 0 };

                // ç‹€æ…‹æ©Ÿ
                this.state = 'idle';
                this.stateTimer = 0;
                this.detectionRange = 500
                this.attackRange = 150;

                this.initializeByType();
            }

            initializeByType() {
                switch(this.type) {
                    case 'patrol':
                        this.patrolPoints = [
                            { x: this.x - 100, y: this.y },
                            { x: this.x + 100, y: this.y }
                        ];
                        this.state = 'patrolling';
                        break;
                    case 'dasher':
                        this.dashCooldown = 0;
                        this.state = 'waiting';
                        break;
                    case 'chaser':
                    default:
                        this.state = 'chasing';
                        break;
                }
            }

            update() {
                this.stateTimer++;

                // è¨ˆç®—åˆ°ç©å®¶çš„è·é›¢
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // æ›´æ–°ç©å®¶ä½ç½®é æ¸¬
                this.updatePathPrediction();

                // æ ¹æ“šé¡å‹åŸ·è¡Œä¸åŒçš„AI
                switch(this.type) {
                    case 'chaser':
                        this.updateChaser(distance);
                        break;
                    case 'patrol':
                        this.updatePatrol(distance);
                        break;
                    case 'dasher':
                        this.updateDasher(distance);
                        break;
                }

                // æ›´æ–°è¡åˆºç‹€æ…‹
                this.updateDash();
            }

            updatePathPrediction() {
                // è¨ˆç®—ç©å®¶é€Ÿåº¦
                const playerVx = player.x - this.lastPlayerPos.x;
                const playerVy = player.y - this.lastPlayerPos.y;

                // é æ¸¬ç©å®¶æœªä¾†ä½ç½®ï¼ˆåŸºæ–¼ç•¶å‰é€Ÿåº¦ï¼‰
                const predictionFrames = Math.min(30, this.predictionFrames + 1);
                this.predictedPos.x = player.x + playerVx * predictionFrames * 0.5;
                this.predictedPos.y = player.y + playerVy * predictionFrames * 0.5;

                // æ›´æ–°è¨˜éŒ„
                this.lastPlayerPos.x = player.x;
                this.lastPlayerPos.y = player.y;
                this.predictionFrames = predictionFrames;
            }

            updateChaser(distance) {
                // æ™ºèƒ½è¿½è¹¤æ¨¡å¼
                let targetX, targetY;

                if (distance < this.attackRange) {
                    // è¿‘è·é›¢ç›´æ¥è¿½è¹¤
                    targetX = player.x;
                    targetY = player.y;
                } else {
                    // é è·é›¢ä½¿ç”¨é æ¸¬ä½ç½®
                    targetX = this.predictedPos.x;
                    targetY = this.predictedPos.y;
                }

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const targetDistance = Math.sqrt(dx * dx + dy * dy);

                if (targetDistance > 0) {
                    this.x += (dx / targetDistance) * this.speed;
                    this.y += (dy / targetDistance) * this.speed;
                }
            }

            updatePatrol(distance) {
                if (distance < this.detectionRange) {
                    // ç™¼ç¾ç©å®¶ï¼Œåˆ‡æ›åˆ°è¿½è¹¤æ¨¡å¼
                    this.state = 'chasing';
                    this.updateChaser(distance);
                } else {
                    // ç¹¼çºŒå·¡é‚
                    if (this.patrolPoints.length > 0) {
                        const target = this.patrolPoints[this.currentPatrolIndex];
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const patrolDistance = Math.sqrt(dx * dx + dy * dy);

                        if (patrolDistance < 10) {
                            // åˆ°é”å·¡é‚é»ï¼Œåˆ‡æ›åˆ°ä¸‹ä¸€å€‹
                            this.currentPatrolIndex = (this.currentPatrolIndex + this.patrolDirection + this.patrolPoints.length) % this.patrolPoints.length;
                            if (this.currentPatrolIndex === 0 || this.currentPatrolIndex === this.patrolPoints.length - 1) {
                                this.patrolDirection *= -1;
                            }
                        } else {
                            // ç§»å‹•åˆ°å·¡é‚é»
                            this.x += (dx / patrolDistance) * this.speed * 0.7;
                            this.y += (dy / patrolDistance) * this.speed * 0.7;
                        }
                    }
                }
            }

            updateDasher(distance) {
                if (this.dashCooldown > 0) {
                    this.dashCooldown--;
                }

                switch(this.state) {
                    case 'waiting':
                        if (distance < this.detectionRange && this.dashCooldown === 0) {
                            this.state = 'preparing';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'preparing':
                        // æº–å‚™è¡åˆºéšæ®µï¼ˆ1ç§’æº–å‚™æ™‚é–“ï¼‰
                        if (this.stateTimer > 60) {
                            this.startDash();
                            this.state = 'dashing';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'dashing':
                        // è¡åˆºéšæ®µ
                        if (this.dashDuration > 0) {
                            this.x += this.dashDirection.x * this.speed * 3;
                            this.y += this.dashDirection.y * this.speed * 3;
                            this.dashDuration--;
                        } else {
                            this.state = 'cooldown';
                            this.dashCooldown = 180; // 3ç§’å†·å»
                            this.stateTimer = 0;
                        }
                        break;

                    case 'cooldown':
                        if (this.stateTimer > 60) {
                            this.state = 'waiting';
                        }
                        break;
                }
            }

            startDash() {
                // è¨ˆç®—è¡åˆºæ–¹å‘ï¼ˆæœå‘é æ¸¬ä½ç½®ï¼‰
                const dx = this.predictedPos.x - this.x;
                const dy = this.predictedPos.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.dashDirection.x = dx / distance;
                    this.dashDirection.y = dy / distance;
                } else {
                    this.dashDirection.x = 0;
                    this.dashDirection.y = 0;
                }

                this.dashDuration = 30; // 0.5ç§’è¡åˆºæ™‚é–“
                this.isDashing = true;
            }

            updateDash() {
                if (this.dashDuration <= 0) {
                    this.isDashing = false;
                }
            }

            draw(ctx) {
                // æ ¹æ“šç‹€æ…‹æ”¹è®Šé¡è‰²
                let color = this.color;
                let emoji = 'ğŸ‘¿';

                switch(this.type) {
                    case 'patrol':
                        color = this.state === 'chasing' ? '#e74c3c' : '#f39c12';
                        emoji = this.state === 'chasing' ? 'ğŸ˜ ' : 'ğŸš¶';
                        break;
                    case 'dasher':
                        if (this.state === 'preparing') {
                            color = '#f1c40f';
                            emoji = 'âš¡';
                        } else if (this.isDashing) {
                            color = '#9b59b6';
                            emoji = 'ğŸ’¨';
                        } else {
                            color = '#34495e';
                            emoji = 'ğŸ˜´';
                        }
                        break;
                    case 'chaser':
                    default:
                        emoji = 'ğŸ‘¹';
                        break;
                }

                // ç¹ªè£½æ•µäºº
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // ç¹ªè£½è¡¨æƒ…
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(emoji, this.x + this.width/2, this.y + this.height/2 + 5);

                // ç¹ªè£½ç‹€æ…‹æŒ‡ç¤ºå™¨
                if (this.type === 'dasher' && this.state === 'preparing') {
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 20, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }
        
        // å½±å­éšŠå‹æ•¸çµ„
        let echoes = [];
        
        // ç•¶å‰é—œå¡é…ç½®
        let currentLevel = 1;
        
        // æ•µäººç¢°æ’æª¢æ¸¬
        function checkEnemyCollisions() {
            const level = getCurrentLevel();
            if (!level.enemies) return;

            level.enemies.forEach(enemy => {
                if (isColliding(player, enemy) && !player.isInvulnerable) {
                    player.isInvulnerable = true;
                    player.invulnerableTimer = Date.now();
                    resetPlayerPosition();
                }
            });

            // æ›´æ–°ç„¡æ•µç‹€æ…‹
            if (player.isInvulnerable) {
                if (Date.now() - player.invulnerableTimer > 2000) { // 2ç§’ç„¡æ•µæ™‚é–“
                    player.isInvulnerable = false;
                }
            }
        }

        // é—œå¡è¨­è¨ˆ
        const levels = {
            1: {
                tutorial: [
                    {x: 100, y: 150, color: '#FFFFFF', text: "ä½¿ç”¨ WASD æˆ–æ–¹å‘éµæ§åˆ¶ç§»å‹•"},
                    {x: 300, y: 200, color: '#FFFFFF', text: "è¸©ä¸‹ç´…è‰²æ©Ÿé—œ âš¡"},  
                    {x: 500, y: 250, color: '#FFFFFF', text: "æŒ‰ P éµå‰µé€ å½±å­"},  
                    {x: 700, y: 300, color: '#FFFFFF', text: "Ctrl+R é‡æ–°é–‹å§‹éŠæˆ²"},
                    {x: 900, y: 350, color: '#FFFF00', text: "Ctrl+1~5 è·³é—œ"}
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 200, y: 450, width: 150, height: 20, color: '#8B4513'},
                    {x: 500, y: 380, width: 100, height: 20, color: '#8B4513'},
                    {x: 700, y: 300, width: 120, height: 20, color: '#8B4513'},
                    {x: 900, y: 220, width: 100, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 250, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 550, y: 350, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 750, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'}
                ],
                movingPlatforms: [
                    {x: 400, y: 450, width: 80, height: 15, vx: 2, minX: 350, maxX: 450, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 150, y: 530, width: 40, height: 20, bounceForce: 20, color: '#f39c12'}
                ],
                goal: {x: 1050, y: 170, width: 40, height: 40, color: '#27ae60'}
            },
            2: {
                enemies: [
                    new Enemy(300, 500, 25, 25, 1, 'patrol')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 100, y: 480, width: 80, height: 20, color: '#8B4513'},
                    {x: 300, y: 420, width: 80, height: 20, color: '#8B4513'},
                    {x: 500, y: 360, width: 80, height: 20, color: '#8B4513'},
                    {x: 700, y: 300, width: 80, height: 20, color: '#8B4513'},
                    {x: 900, y: 240, width: 80, height: 20, color: '#8B4513'},
                    {x: 1100, y: 180, width: 80, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 130, y: 450, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 330, y: 390, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 530, y: 330, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 730, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'}
                ],
                movingPlatforms: [
                    {x: 200, y: 350, width: 60, height: 15, vx: 1.5, minX: 180, maxX: 280, color: '#9b59b6'},
                    {x: 800, y: 200, width: 60, height: 15, vx: -2, minX: 750, maxX: 850, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 450, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 650, y: 530, width: 40, height: 20, bounceForce: 22, color: '#f39c12'}
                ],
                goal: {x: 1120, y: 140, width: 40, height: 40, color: '#27ae60'}
            },
            3: {
                enemies: [
                    new Enemy(200, 500, 25, 25, 1, 'chaser'),
                    new Enemy(600, 500, 25, 25, 1, 'dasher')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 100, y: 450, width: 100, height: 20, color: '#8B4513'},
                    {x: 300, y: 350, width: 100, height: 20, color: '#8B4513'},
                    {x: 500, y: 250, width: 100, height: 20, color: '#8B4513'},
                    {x: 700, y: 200, width: 100, height: 20, color: '#8B4513'},
                    {x: 900, y: 150, width: 100, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 120, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 320, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 520, y: 220, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 720, y: 170, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]}
                ],
                movingPlatforms: [
                    {x: 200, y: 400, width: 60, height: 15, vx: 2, minX: 150, maxX: 250, color: '#9b59b6'},
                    {x: 400, y: 300, width: 60, height: 15, vx: 2, minX: 350, maxX: 450, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 150, y: 530, width: 40, height: 20, bounceForce: 22, color: '#f39c12'}
                ],
                goal: {x: 950, y: 100, width: 40, height: 40, color: '#27ae60'}
            },
            4: {
                enemies: [
                    new Enemy(300, 500, 25, 25, 1.2, 'patrol'),
                    new Enemy(600, 500, 25, 25, 1.2, 'dasher'),
                    new Enemy(900, 500, 25, 25, 1.2, 'chaser')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 150, y: 450, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 400, width: 80, height: 20, color: '#8B4513'},
                    {x: 650, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 900, y: 300, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 200, width: 400, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 170, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 420, y: 370, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 670, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 920, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]},
                    {x: 585, y: 170, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [3]}
                ],
                movingPlatforms: [
                    {x: 300, y: 350, width: 60, height: 15, vx: 3, minX: 250, maxX: 350, color: '#9b59b6'},
                    {x: 550, y: 300, width: 60, height: 15, vx: -3, minX: 500, maxX: 600, color: '#9b59b6'},
                    {x: 800, y: 250, width: 60, height: 15, vx: 3, minX: 750, maxX: 850, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 200, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 450, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 700, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'}
                ],
                goal: {x: 580, y: 120, width: 40, height: 40, color: '#27ae60'}
            },
            5: {
                enemies: [
                    new Enemy(600, 450, 50, 50, 0.5, 'patrol'),
                    new Enemy(800, 450, 20, 30, 3, 'dasher'),
                    new Enemy(600, 600, 20, 20, 1.75, 'chaser'),
                    new Enemy(400, 450, 20, 30, 3, 'dasher')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 200, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 300, width: 70, height: 20, color: '#8B4513'},
                    {x: 600, y: 250, width: 60, height: 20, color: '#8B4513'},
                    {x: 800, y: 300, width: 70, height: 20, color: '#8B4513'},
                    {x: 1000, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 600, y: 150, width: 200, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 215, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 415, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 615, y: 220, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 815, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]},
                    {x: 1015, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [3]},
                    {x: 600, y: 120, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [4]}
                ],
                movingPlatforms: [
                    {x: 200, y: 420, width: 60, height: 15, vx: 2, minX: 180, maxX: 280, color: '#9b59b6'},
                    {x: 400, y: 370, width: 60, height: 15, vx: -2, minX: 380, maxX: 480, color: '#9b59b6'},
                    {x: 600, y: 320, width: 60, height: 15, vx: 2, minX: 580, maxX: 680, color: '#9b59b6'},
                    {x: 800, y: 270, width: 60, height: 15, vx: -2, minX: 780, maxX: 880, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 600, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 550, y: 230, width: 40, height: 20, bounceForce: 15, color: '#f39c12'},
                    {x: 250, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 950, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'}
                ],
                goal: {x: 580, y: 70, width: 40, height: 40, color: '#27ae60'}
            }
        };
        
        // ç²å–ç•¶å‰é—œå¡
        function getCurrentLevel() {
            return levels[currentLevel] || levels[1];
        }
        
        // é‡åŠ›
        const gravity = 0.8;
        
        // é–‹å§‹éŠæˆ²
        function startGame() {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.display = 'none';
            // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
            initAudio();
            // åˆå§‹åŒ–éŠæˆ²
            initGame();
        }

        function initGame() {
            resetGame();
            resetPlayerPosition();
            gameState.isRoundActive = true;
        }

        // éŸ³æ•ˆç³»çµ±
        const audio = {
            bgm: new Audio('assets/bgm.mp3'),
            switch: new Audio('assets/switch.mp3'),
            jump: new Audio('assets/jump.mp3'),
            shift: new Audio('assets/shift.mp3'),
            tada: new Audio('asests/tada.mp3'),
            final: new Audio('assets/final.mp3')
        };

        function initAudio() {
            audio.bgm.loop = true;
            audio.bgm.volume = 0.5;
            // é è¨­é–‹å•ŸéŸ³æ¨‚
            audio.bgm.play();
            document.getElementById('bgmBtn').textContent = 'éŸ³æ¨‚ï¼šé–‹';
        }

        function toggleBGM() {
            const btn = document.getElementById('bgmBtn');
            if (audio.bgm.paused) {
                audio.bgm.play();
                btn.textContent = 'éŸ³æ¨‚ï¼šé–‹';
            } else {
                audio.bgm.pause();
                btn.textContent = 'éŸ³æ¨‚ï¼šé—œ';
            }
        }

        // é€Ÿåº¦æ§åˆ¶
        const speeds = {
            slow: 3,
            normal: 5,
            fast: 7
        };

        function setSpeed(speedType) {
            player.speed = speeds[speedType];
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.style.background = '#333';
            });
            event.target.style.background = '#27ae60';
        }

        // éµç›¤è¼¸å…¥
        const keys = {
            left: false,
            right: false,
            up: false
        };
        
        // äº‹ä»¶ç›£è½
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    keys.left = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = true;
                    break;
                case 'w':
                case 'arrowup':
                    if (!keys.up) {  // åªåœ¨é¦–æ¬¡æŒ‰ä¸‹æ™‚è¨­ç½®
                        keys.up = true;
                        if (player.onGround) {
                            player.vy = -player.jumpPower;
                            player.onGround = false;
                            audio.jump.play();
                        }
                    }
                    break;
                case 'p':
                    if (audio.shift) audio.shift.play();
                    e.preventDefault();
                    startNewRound();
                    break;
                case 'r':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        resetGame();
                    }
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                    // å·è·³é—œåŠŸèƒ½
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const targetLevel = parseInt(e.key);
                        if (targetLevel >= 1 && targetLevel <= 5) {
                            jumpToLevel(targetLevel);
                        }
                    }
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    keys.left = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = false;
                    break;
                case 'w':
                case 'arrowup':
                    keys.up = false;
                    break;
            }
        });
        
        // æ›´æ–°ç©å®¶
        function updatePlayer() {
            if (!gameState.isRoundActive) return;
            
            // æª¢æŸ¥å›åˆæ™‚é–“é™åˆ¶
            const roundTime = Date.now() - gameState.roundStartTime;
            if (roundTime > ROUND_TIME_LIMIT) {
                startNewRound();
                return;
            }
            
            // è¨˜éŒ„ç•¶å‰ç‹€æ…‹
            const currentTime = Date.now() - gameState.roundStartTime;
            player.recording.push({
                time: currentTime,
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                action: getPlayerAction()
            });
            
            // æ°´å¹³ç§»å‹•
            if (keys.left) {
                player.vx = -player.speed;
            } else if (keys.right) {
                player.vx = player.speed;
            } else {
                player.vx *= 0.8; // æ‘©æ“¦åŠ›
            }
            
            // é‡åŠ›
            player.vy += gravity;
            
            // æ›´æ–°ä½ç½®
            player.x += player.vx;
            player.y += player.vy;
            
            // é‚Šç•Œæª¢æŸ¥
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            // ç¢°æ’æª¢æ¸¬
            player.onGround = false;
            checkCollisions(player);
            
            // æª¢æŸ¥ç›®æ¨™ï¼ˆåªæœ‰åœ¨æ‰€æœ‰æ©Ÿé—œéƒ½æ¿€æ´»æ™‚æ‰èƒ½éé—œï¼‰
            if (isColliding(player, getCurrentLevel().goal) && allSwitchesActivated()) {
                gameState.goalReached = true;
                gameState.isRoundActive = false;
                showGoalMessage();
            }
            
            // æ‰è½é‡ç½®
            if (player.y > canvas.height) {
                resetPlayerPosition();
            }
        }
        
        // æ›´æ–°å½±å­
        function updateEchoes() {
            const currentTime = Date.now() - gameState.roundStartTime;
            
            echoes.forEach(echo => {
                // æ ¹æ“šè¨˜éŒ„æ›´æ–°å½±å­ä½ç½®
                for (let i = 0; i < echo.recording.length; i++) {
                    const record = echo.recording[i];
                    if (record.time <= currentTime) {
                        echo.x = record.x;
                        echo.y = record.y;
                        echo.vx = record.vx;
                        echo.vy = record.vy;
                        echo.currentAction = record.action;
                    } else {
                        break;
                    }
                }
                
                // å½±å­é‡åŠ›å’Œç¢°æ’
                echo.vy += gravity;
                echo.y += echo.vy;
                echo.onGround = false;
                checkCollisions(echo);
                
                if (echo.y > canvas.height) {
                    echo.x = 50;
                    echo.y = 400;
                    echo.vx = 0;
                    echo.vy = 0;
                }
            });
        }
        
        // æ›´æ–°ç§»å‹•å¹³å°
        function updateMovingPlatforms() {
            const level = getCurrentLevel();
            if (!level.movingPlatforms) return;
            
            level.movingPlatforms.forEach(platform => {
                platform.x += platform.vx;
                if (platform.x <= platform.minX || platform.x >= platform.maxX) {
                    platform.vx = -platform.vx;
                }
            });
        }
        
        // æª¢æŸ¥ç¢°æ’
        function checkCollisions(entity) {
            const level = getCurrentLevel();
            
            // æª¢æŸ¥æ™®é€šå¹³å°
            level.platforms.forEach(platform => {
                if (isColliding(entity, platform)) {
                    if (entity.vy > 0 && entity.y < platform.y) {
                        entity.y = platform.y - entity.height;
                        entity.vy = 0;
                        entity.onGround = true;
                    }
                }
            });
            
            // æª¢æŸ¥ç§»å‹•å¹³å°
            if (level.movingPlatforms) {
                level.movingPlatforms.forEach(platform => {
                    if (isColliding(entity, platform)) {
                        if (entity.vy > 0 && entity.y < platform.y) {
                            entity.y = platform.y - entity.height;
                            entity.vy = 0;
                            entity.onGround = true;
                            // å¹³å°å¸¶å‹•æ•ˆæœ
                            entity.x += platform.vx;
                        }
                    }
                });
            }
            
            // æª¢æŸ¥å½ˆè·³æ¿
            if (level.bouncePads) {
                level.bouncePads.forEach(pad => {
                    if (isColliding(entity, pad) && entity.vy > 0) {
                        entity.vy = -pad.bounceForce;
                        entity.onGround = false;
                    }
                });
            }
        }
        
        // ç¢°æ’æª¢æ¸¬
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // æª¢æŸ¥æ©Ÿé—œæ¿€æ´»
        function checkSwitchActivation() {
            const level = getCurrentLevel();
            
            level.switches.forEach((sw, index) => {
                // æª¢æŸ¥å‰ç½®æ¢ä»¶
                if (sw.required && sw.required.length > 0) {
                    const prerequisitesMet = sw.required.every(reqIndex => 
                        level.switches[reqIndex].activated
                    );
                    if (!prerequisitesMet) {
                        sw.activated = false;
                        return;
                    }
                }

                let activated = false;
                
                // æª¢æŸ¥ç©å®¶
                if (isColliding(player, sw)) {
                    activated = true;
                }
                
                // æª¢æŸ¥å½±å­
                echoes.forEach(echo => {
                    if (isColliding(echo, sw)) {
                        activated = true;
                    }
                });
                
                if (activated && !sw.activated) {
                    audio.switch.play();
                }
                sw.activated = activated;
            });
        }
        
        // æª¢æŸ¥æ‰€æœ‰æ©Ÿé—œæ˜¯å¦éƒ½æ¿€æ´»
        function allSwitchesActivated() {
            const level = getCurrentLevel();
            return level.switches.every(sw => sw.activated);
        }
        
        // ç²å–ç©å®¶å‹•ä½œ
        function getPlayerAction() {
            if (keys.left) return 'left';
            if (keys.right) return 'right';
            if (keys.up) return 'jump';
            return 'idle';
        }
        
        // é‡ç½®ç©å®¶ä½ç½®
        function resetPlayerPosition() {
            player.x = 50;
            player.y = 400;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.wasJumping = false;
        }
        
        // é–‹å§‹æ–°å›åˆ
        function startNewRound() {
            // ä¿å­˜ç•¶å‰å›åˆçš„è¨˜éŒ„ï¼ˆå¦‚æœæœ‰å‹•ä½œè¨˜éŒ„ï¼‰
            if (player.recording.length > 10) { // åªæœ‰æœ‰æ„ç¾©çš„è¨˜éŒ„æ‰ä¿å­˜
                const newEcho = {
                    x: 50,
                    y: 400,
                    width: 30,
                    height: 30,
                    vx: 0,
                    vy: 0,
                    onGround: false,
                    color: `rgba(52, 152, 219, ${Math.max(0.3, 1 - echoes.length * 0.15)})`,
                    recording: [...player.recording],
                    currentAction: 'idle'
                };
                echoes.push(newEcho);
                
                // é™åˆ¶å½±å­æ•¸é‡
                if (echoes.length > MAX_ECHOES) {
                    echoes.shift(); // ç§»é™¤æœ€è€çš„å½±å­
                }
            }
            
            // é‡ç½®ç©å®¶
            resetPlayerPosition();
            player.recording = [];
            
            // é‡ç½®æ©Ÿé—œ
            const level = getCurrentLevel();
            level.switches.forEach(sw => sw.activated = false);
            
            // æ›´æ–°éŠæˆ²ç‹€æ…‹
            gameState.round++;
            gameState.roundStartTime = Date.now();
            gameState.isRoundActive = true;
            gameState.goalReached = false;
            
            // é¡¯ç¤ºå›åˆè³‡è¨Š
            showRoundInfo();
            
            // ç§»é™¤ç›®æ¨™é”æˆæ¶ˆæ¯
            const goalMsg = document.querySelector('.goal-reached');
            if (goalMsg) goalMsg.remove();
        }
        
        // é¡¯ç¤ºå›åˆè³‡è¨Š
        function showRoundInfo() {
            const roundInfo = document.createElement('div');
            roundInfo.className = 'round-info';
            roundInfo.innerHTML = `
                å›åˆ ${gameState.round}<br>
                å½±å­æ•¸é‡: ${echoes.length}/${MAX_ECHOES}<br>
                <small>éœ€è¦åŒæ™‚æ¿€æ´»æ‰€æœ‰æ©Ÿé—œï¼</small>
            `;
            document.getElementById('gameContainer').appendChild(roundInfo);
            
            setTimeout(() => {
                roundInfo.remove();
            }, 2000);
        }
        
        // é‡ç½®æ•´å€‹éŠæˆ²
        function resetGame() {
            // é‡ç½®å½±å­å’Œç©å®¶
            echoes = [];
            resetPlayerPosition();
            player.recording = [];
            
            // åªé‡ç½®ç•¶å‰é—œå¡çš„å›åˆæ•¸å’Œæ™‚é–“
            gameState.round = 1;
            gameState.levelStats[currentLevel].startTime = Date.now();
            gameState.roundStartTime = Date.now();
            gameState.isRoundActive = true;
            gameState.goalReached = false;
            gameState.showingRoundInfo = false;
            
            // åªé‡ç½®ç•¶å‰é—œå¡çš„æ©Ÿé—œ
            const level = getCurrentLevel();
            if (level.switches) {
                level.switches.forEach(sw => sw.activated = false);
            }
            
            // æ¸…é™¤æ‰€æœ‰UIæ¶ˆæ¯
            document.querySelectorAll('.goal-reached, .round-info, .game-complete').forEach(el => el.remove());
        }
        
        // é€²å…¥ä¸‹ä¸€é—œ
        function nextLevel() {
            if (levels[currentLevel + 1]) {
                // ä¿å­˜ç•¶å‰é—œå¡çš„çµ±è¨ˆ
                gameState.levelStats[currentLevel].rounds = gameState.round;
                
                currentLevel++;
                gameState.level = currentLevel;
                
                // åˆå§‹åŒ–æ–°é—œå¡çš„çµ±è¨ˆ
                gameState.levelStats[currentLevel].startTime = Date.now();
                gameState.round = 1;
                echoes = [];
                resetPlayerPosition();
                player.recording = [];
                
                // é‡ç½®ç•¶å‰é—œå¡çš„æ©Ÿé—œ
                const level = getCurrentLevel();
                level.switches.forEach(sw => sw.activated = false);
                
                // æ›´æ–°éŠæˆ²ç‹€æ…‹
                gameState.roundStartTime = Date.now();
                gameState.isRoundActive = true;
                gameState.goalReached = false;
                
                // æ¸…é™¤æ‰€æœ‰æ¶ˆæ¯
                document.querySelectorAll('.goal-reached, .round-info').forEach(el => el.remove());
            }
        }
        
        // è·³åˆ°æŒ‡å®šé—œå¡
        function jumpToLevel(targetLevel) {
            if (targetLevel >= 1 && targetLevel <= 5) {
                currentLevel = targetLevel;
                gameState.level = targetLevel;
                
                // é‡ç½®ç•¶å‰é—œå¡
                gameState.round = 1;
                gameState.levelStats[currentLevel].startTime = Date.now();
                gameState.roundStartTime = Date.now();
                
                // æ¸…é™¤å½±å­å’Œé‡ç½®ç©å®¶
                echoes = [];
                resetPlayerPosition();
                player.recording = [];
                
                // é‡ç½®ç•¶å‰é—œå¡çš„æ©Ÿé—œ
                const level = getCurrentLevel();
                if (level.switches) {
                    level.switches.forEach(sw => sw.activated = false);
                }
                
                // æ›´æ–°éŠæˆ²ç‹€æ…‹
                gameState.isRoundActive = true;
                gameState.goalReached = false;
                gameState.showingRoundInfo = false;
                
                // æ¸…é™¤æ‰€æœ‰UIæ¶ˆæ¯
                document.querySelectorAll('.goal-reached, .round-info, .game-complete').forEach(el => el.remove());
                
                // é¡¯ç¤ºè·³é—œæ¶ˆæ¯
                showJumpMessage(targetLevel);
            }
        }
        
        // é¡¯ç¤ºè·³é—œæ¶ˆæ¯
        function showJumpMessage(level) {
            const jumpMsg = document.createElement('div');
            jumpMsg.className = 'round-info';
            jumpMsg.innerHTML = `
                ğŸš€ è·³åˆ°é—œå¡ ${level}ï¼<br>
                <small>Ctrl+æ•¸å­—éµå¯å¿«é€Ÿè·³é—œ</small>
            `;
            document.getElementById('gameContainer').appendChild(jumpMsg);
            
            setTimeout(() => {
                jumpMsg.remove();
            }, 2000);
        }
        
        // é¡¯ç¤ºçµç®—ç•«é¢
        function showGameComplete() {
            audio.final.play();
            const completionMsg = document.createElement('div');
            completionMsg.className = 'game-complete';
            
            // è¨ˆç®—æ‰€æœ‰é—œå¡çš„ç¸½å›åˆæ•¸å’Œæ™‚é–“
            let totalRounds = 0;
            let totalTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            
            // è¨ˆç®—æ¯é—œçš„çµ±è¨ˆæ•¸æ“š
            let levelStats = [];
            for (let i = 1; i <= 5; i++) {
                const stats = gameState.levelStats[i];
                const rounds = i === currentLevel ? gameState.round : stats.rounds;
                totalRounds += rounds;
                
                const time = i === currentLevel ? 
                    Math.floor((Date.now() - stats.startTime) / 1000) :
                    (i < currentLevel ? 
                        Math.floor((gameState.levelStats[i + 1].startTime - stats.startTime) / 1000) : 0);
                
                levelStats.push(`
                    <p>ğŸ¯ é—œå¡ ${i}: ${rounds} å›åˆï¼Œ${time} ç§’</p>
                `);
            }
            
            completionMsg.innerHTML = `
                <h2>ğŸ® éŠæˆ²é€šé—œï¼</h2>
                <div class="stats">
                    <p>ğŸŒŸ ç¸½é€šé—œæ™‚é–“: ${totalTime} ç§’</p>
                    <p>ğŸ”„ ç¸½å›åˆæ•¸: ${totalRounds}</p>
                    <p>âš¡ å¹³å‡æ¯é—œå›åˆ: ${Math.round(totalRounds / 5)} å›åˆ</p>
                    <p>â±ï¸ å¹³å‡æ¯é—œæ™‚é–“: ${Math.round(totalTime / 5)} ç§’</p>
                    <hr>
                    <h3>å„é—œå¡çµ±è¨ˆ</h3>
                    ${levelStats.join('')}
                </div>
                <div class="rating">
                    ${getRating(totalTime, totalRounds)}
                </div>
                
            `;
            document.getElementById('gameContainer').appendChild(completionMsg);
        }

        // æ ¹æ“šè¡¨ç¾è©•åˆ†
        function getRating(time, rounds) {
            let stars = 3;
            const avgTimePerLevel = time / 5;
            const avgRoundsPerLevel = rounds / 5;        
            if (time > 180) stars--; // ç¸½æ™‚é–“è¶…é3åˆ†é˜æ¸›ä¸€æ˜Ÿ
            if (rounds > 30) stars--; // ç¸½å›åˆè¶…é30å›åˆæ¸›ä¸€æ˜Ÿ
            return 'â­'.repeat(stars);
        }

        // é¡¯ç¤ºç›®æ¨™é”æˆæ¶ˆæ¯
        function showGoalMessage() {
            audio.tada.play();
            const goalMsg = document.createElement('div');
            goalMsg.className = 'goal-reached';
            
            if (currentLevel === 5) {
                showGameComplete();
                return;
            }

            goalMsg.innerHTML = `
                ğŸ‰ é—œå¡ ${currentLevel} å®Œæˆï¼<br>
                ç”¨äº† ${gameState.round} å›åˆ<br>
                <small>${levels[currentLevel + 1] ? 'é€²å…¥ä¸‹ä¸€é—œ' : 'é‡æ–°é–‹å§‹'}</small>
            `;
            document.getElementById('gameContainer').appendChild(goalMsg);
            
            // 3ç§’å¾Œè‡ªå‹•é€²å…¥ä¸‹ä¸€é—œæˆ–é‡é–‹
            setTimeout(() => {
                if (levels[currentLevel + 1]) {
                    nextLevel();
                } else {
                    resetGame();
                }
            }, 500);
        }
        
        // ç¹ªè£½å‡½æ•¸
        function draw() {
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const level = getCurrentLevel();
            
            // ç¹ªè£½å¹³å°
            level.platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });
            
            // ç¹ªè£½ç§»å‹•å¹³å°
            if (level.movingPlatforms) {
                level.movingPlatforms.forEach(platform => {
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // ç§»å‹•å¹³å°æ¨™ç¤º
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â–¶', platform.x + platform.width/2, platform.y + platform.height/2 + 4);
                });
            }
            
            // ç¹ªè£½å½ˆè·³æ¿
            if (level.bouncePads) {
                level.bouncePads.forEach(pad => {
                    ctx.fillStyle = pad.color;
                    ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
                    
                    // å½ˆè·³æ¿æ¨™ç¤º
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â†‘', pad.x + pad.width/2, pad.y + pad.height/2 + 5);
                });
            }
            
            // ç¹ªè£½æ©Ÿé—œ
            level.switches.forEach((sw, index) => {
                ctx.fillStyle = sw.activated ? '#2ecc71' : sw.color;
                ctx.fillRect(sw.x, sw.y, sw.width, sw.height);
                
                // æ©Ÿé—œæ¨™ç¤ºå’Œç·¨è™Ÿ
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(sw.activated ? 'âœ“' : 'âš¡', sw.x + sw.width/2, sw.y + sw.height/2);
                ctx.font = '12px Arial';
                ctx.fillText(`#${index + 1}`, sw.x + sw.width/2, sw.y - 5);
            });
            
            // ç¹ªè£½ç›®æ¨™ï¼ˆæ ¹æ“šæ©Ÿé—œç‹€æ…‹æ”¹è®Šé¡è‰²ï¼‰
            const allActivated = allSwitchesActivated();
            ctx.fillStyle = allActivated ? level.goal.color : '#95a5a6';
            ctx.fillRect(level.goal.x, level.goal.y, level.goal.width, level.goal.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(allActivated ? 'ğŸ¯' : 'ğŸ”’', level.goal.x + level.goal.width/2, level.goal.y + level.goal.height/2 + 7);
            
            // ç¹ªè£½å½±å­
            echoes.forEach((echo, index) => {
                ctx.fillStyle = echo.color;
                ctx.fillRect(echo.x, echo.y, echo.width, echo.height);
                
                // å½±å­ç·¨è™Ÿ
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(index + 1, echo.x + echo.width/2, echo.y + echo.height/2 + 4);
            });
            
            // ç¹ªè£½ç©å®¶
            ctx.fillStyle = player.isInvulnerable ? 'rgba(231, 76, 60, 0.5)' : player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ‘¤', player.x + player.width/2, player.y + player.height/2 + 5);
            
            // ç¹ªè£½æ•™å­¸æ–‡å­—
            if (currentLevel === 1 && level.tutorial) {
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                level.tutorial.forEach(tip => {
                    ctx.fillStyle = tip.color || '#FFFFFF';
                    ctx.fillText(tip.text, tip.x, tip.y);
                });
            }

            // ç¹ªè£½æ•µäºº
            if (level.enemies) {
                level.enemies.forEach(enemy => {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    // æ•µäººè¡¨æƒ…
                    ctx.fillStyle = 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ğŸ‘¿', enemy.x + enemy.width/2, enemy.y + enemy.height/2 + 5);
                });
            }

            // ç¹ªè£½å›åˆæ™‚é–“æ¢
            if (gameState.isRoundActive) {
                const roundTime = Date.now() - gameState.roundStartTime;
                const timePercent = Math.min(roundTime / ROUND_TIME_LIMIT, 1);
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(20, canvas.height - 30, canvas.width - 40, 10);
                
                ctx.fillStyle = timePercent > 0.8 ? '#e74c3c' : '#3498db';
                ctx.fillRect(20, canvas.height - 30, (canvas.width - 40) * timePercent, 10);
            }
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('echoCount').textContent = echoes.length;
            document.getElementById('totalTimer').textContent = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            document.getElementById('level').textContent = gameState.level;
        }
        
        // æ›´æ–°æ•µäºº
        function updateEnemies() {
            const level = getCurrentLevel();
            if (!level.enemies) return;
            level.enemies.forEach(enemy => enemy.update());
        }

        // ä¸»éŠæˆ²å¾ªç’° - å›ºå®š60FPS
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const FRAME_INTERVAL = 1000 / TARGET_FPS;
        
        function gameLoop(currentTime) {
            if (currentTime - lastFrameTime >= FRAME_INTERVAL) {
                updatePlayer();
                updateEchoes();
                updateMovingPlatforms();
                updateEnemies();
                checkSwitchActivation();
                checkEnemyCollisions();
                draw();
                updateUI();
                lastFrameTime = currentTime;
            }
            requestAnimationFrame(gameLoop);
        }
        
        // èª¿æ•´ Canvas å¤§å°å’ŒéŠæˆ²å…ƒç´ æ¯”ä¾‹
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const header = document.getElementById('gameHeader');
            const canvas = document.getElementById('gameCanvas');
            
            // è¨­ç½® canvas çš„é‚è¼¯å¤§å°ï¼ˆéŠæˆ²å…§éƒ¨åæ¨™ç³»çµ±ï¼‰
            const BASE_WIDTH = 1200;
            const BASE_HEIGHT = 600;
            
            // ç²å–å¯ç”¨ç©ºé–“
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight - header.offsetHeight;
            
            // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
            const scale = Math.min(
                availableWidth / BASE_WIDTH,
                availableHeight / BASE_HEIGHT
            );
            
            // è¨­ç½® canvas çš„å¯¦éš›å¤§å°
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            
            // è¨­ç½® CSS ç¸®æ”¾
            canvas.style.width = `${BASE_WIDTH * scale}px`;
            canvas.style.height = `${BASE_HEIGHT * scale}px`;
            
            // ç½®ä¸­ canvas
            canvas.style.left = `${(availableWidth - BASE_WIDTH * scale) / 2}px`;
            
            // æ›´æ–°ç¹ªåœ–ä¸Šä¸‹æ–‡çš„è½‰æ›
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
        window.addEventListener('resize', resizeCanvas);
        
        // åˆå§‹åŒ–å¤§å°
        resizeCanvas();
        
        // é–‹å§‹éŠæˆ²
        gameLoop(0);
    </script>
</body>
</html>