<!DOCTYPE html>
<html lang="zh-TW">
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>時影雙行 — Shadow of Mine</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-content">
            <h1>《時影雙行》Shadow of Mine</h1>
            <p>在一座時空錯亂的城市中，你是唯一還能穿梭過去的存在。透過殘影裝置，你將與「過去的自己」並肩合作，解開錯綜複雜的謎題，重塑命運的脈絡。這是一款融合橫向卷軸操作與時間分身策略的沉浸式平台遊戲。</p>
            <p>每一次穿越，都將留下一段影子行動；而你，必須與這些殘影同步行動、互相配合，才能破解機關、戰勝敵人，甚至改變無法挽回的過去。</p>
            <p>在「記憶」與「現實」交錯的路途中，時間不再只是過去與未來的界線，更是你與自己之間最深的羈絆。</p>
            <button class="start-button" onclick="startGame()">開始遊戲</button>
        </div>
    </div>
    <div id="gameContainer">
        <div id="gameHeader">
            <div id="ui">
                <div>關卡進度: <span id="level">1</span>/5</div>
                <div>當前回合: <span id="round">1</span></div>
                <div>影子數量: <span id="echoCount">0</span>/5</div>
                <div>總時間: <span id="totalTimer">0</span>s</div>
            </div>
            <div class="game-controls">
                <div id="speedControl">
                    <button onclick="setSpeed('slow')" class="speed-btn">慢速</button>
                    <button onclick="setSpeed('normal')" class="speed-btn">中速</button>
                    <button onclick="setSpeed('fast')" class="speed-btn">快速</button>
                </div>
                <div id="musicControl">
                    <button onclick="toggleBGM()" id="bgmBtn">音樂：關</button>
                    <button onclick="resetGame()" class="speed-btn">重置遊戲</button>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 遊戲配置
        const MAX_ECHOES = 5;
        const ROUND_TIME_LIMIT = 20000; // 改回20秒
        
        // 遊戲狀態
        let gameState = {
            round: 1,
            level: 1,
            timer: 0,
            gameStartTime: Date.now(),
            roundStartTime: Date.now(),
            isRoundActive: true,
            goalReached: false,
            showingRoundInfo: false,
            levelStats: {
                1: { rounds: 0, startTime: Date.now() },
                2: { rounds: 0, startTime: 0 },
                3: { rounds: 0, startTime: 0 },
                4: { rounds: 0, startTime: 0 },
                5: { rounds: 0, startTime: 0 }
            }
        };
        
        // 玩家對象
        const player = {
            x: 50,
            y: 400,
            width: 30,
            height: 30,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpPower: 15,
            onGround: false,
            color: '#e74c3c', // 紅色
            recording: [],
            isInvulnerable: false,
            invulnerableTimer: 0,
            wasJumping: false
        };

        // 敵人系統
        class Enemy {
            constructor(x, y, width, height, speed, type = 'chaser') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.originalSpeed = speed;
                this.color = '#e74c3c';
                this.type = type; // 'chaser', 'patrol', 'dasher'

                // 路徑預測
                this.lastPlayerPos = { x: player.x, y: player.y };
                this.predictedPos = { x: player.x, y: player.y };
                this.predictionFrames = 0;

                // 巡邏模式
                this.patrolPoints = [];
                this.currentPatrolIndex = 0;
                this.patrolDirection = 1;

                // 衝刺模式
                this.dashCooldown = 0;
                this.dashDuration = 0;
                this.isDashing = false;
                this.dashDirection = { x: 0, y: 0 };

                // 狀態機
                this.state = 'idle';
                this.stateTimer = 0;
                this.detectionRange = 500
                this.attackRange = 150;

                this.initializeByType();
            }

            initializeByType() {
                switch(this.type) {
                    case 'patrol':
                        this.patrolPoints = [
                            { x: this.x - 100, y: this.y },
                            { x: this.x + 100, y: this.y }
                        ];
                        this.state = 'patrolling';
                        break;
                    case 'dasher':
                        this.dashCooldown = 0;
                        this.state = 'waiting';
                        break;
                    case 'chaser':
                    default:
                        this.state = 'chasing';
                        break;
                }
            }

            update() {
                this.stateTimer++;

                // 計算到玩家的距離
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // 更新玩家位置預測
                this.updatePathPrediction();

                // 根據類型執行不同的AI
                switch(this.type) {
                    case 'chaser':
                        this.updateChaser(distance);
                        break;
                    case 'patrol':
                        this.updatePatrol(distance);
                        break;
                    case 'dasher':
                        this.updateDasher(distance);
                        break;
                }

                // 更新衝刺狀態
                this.updateDash();
            }

            updatePathPrediction() {
                // 計算玩家速度
                const playerVx = player.x - this.lastPlayerPos.x;
                const playerVy = player.y - this.lastPlayerPos.y;

                // 預測玩家未來位置（基於當前速度）
                const predictionFrames = Math.min(30, this.predictionFrames + 1);
                this.predictedPos.x = player.x + playerVx * predictionFrames * 0.5;
                this.predictedPos.y = player.y + playerVy * predictionFrames * 0.5;

                // 更新記錄
                this.lastPlayerPos.x = player.x;
                this.lastPlayerPos.y = player.y;
                this.predictionFrames = predictionFrames;
            }

            updateChaser(distance) {
                // 智能追蹤模式
                let targetX, targetY;

                if (distance < this.attackRange) {
                    // 近距離直接追蹤
                    targetX = player.x;
                    targetY = player.y;
                } else {
                    // 遠距離使用預測位置
                    targetX = this.predictedPos.x;
                    targetY = this.predictedPos.y;
                }

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const targetDistance = Math.sqrt(dx * dx + dy * dy);

                if (targetDistance > 0) {
                    this.x += (dx / targetDistance) * this.speed;
                    this.y += (dy / targetDistance) * this.speed;
                }
            }

            updatePatrol(distance) {
                if (distance < this.detectionRange) {
                    // 發現玩家，切換到追蹤模式
                    this.state = 'chasing';
                    this.updateChaser(distance);
                } else {
                    // 繼續巡邏
                    if (this.patrolPoints.length > 0) {
                        const target = this.patrolPoints[this.currentPatrolIndex];
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const patrolDistance = Math.sqrt(dx * dx + dy * dy);

                        if (patrolDistance < 10) {
                            // 到達巡邏點，切換到下一個
                            this.currentPatrolIndex = (this.currentPatrolIndex + this.patrolDirection + this.patrolPoints.length) % this.patrolPoints.length;
                            if (this.currentPatrolIndex === 0 || this.currentPatrolIndex === this.patrolPoints.length - 1) {
                                this.patrolDirection *= -1;
                            }
                        } else {
                            // 移動到巡邏點
                            this.x += (dx / patrolDistance) * this.speed * 0.7;
                            this.y += (dy / patrolDistance) * this.speed * 0.7;
                        }
                    }
                }
            }

            updateDasher(distance) {
                if (this.dashCooldown > 0) {
                    this.dashCooldown--;
                }

                switch(this.state) {
                    case 'waiting':
                        if (distance < this.detectionRange && this.dashCooldown === 0) {
                            this.state = 'preparing';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'preparing':
                        // 準備衝刺階段（1秒準備時間）
                        if (this.stateTimer > 60) {
                            this.startDash();
                            this.state = 'dashing';
                            this.stateTimer = 0;
                        }
                        break;

                    case 'dashing':
                        // 衝刺階段
                        if (this.dashDuration > 0) {
                            this.x += this.dashDirection.x * this.speed * 3;
                            this.y += this.dashDirection.y * this.speed * 3;
                            this.dashDuration--;
                        } else {
                            this.state = 'cooldown';
                            this.dashCooldown = 180; // 3秒冷卻
                            this.stateTimer = 0;
                        }
                        break;

                    case 'cooldown':
                        if (this.stateTimer > 60) {
                            this.state = 'waiting';
                        }
                        break;
                }
            }

            startDash() {
                // 計算衝刺方向（朝向預測位置）
                const dx = this.predictedPos.x - this.x;
                const dy = this.predictedPos.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    this.dashDirection.x = dx / distance;
                    this.dashDirection.y = dy / distance;
                } else {
                    this.dashDirection.x = 0;
                    this.dashDirection.y = 0;
                }

                this.dashDuration = 30; // 0.5秒衝刺時間
                this.isDashing = true;
            }

            updateDash() {
                if (this.dashDuration <= 0) {
                    this.isDashing = false;
                }
            }

            draw(ctx) {
                // 根據狀態改變顏色
                let color = this.color;
                let emoji = '👿';

                switch(this.type) {
                    case 'patrol':
                        color = this.state === 'chasing' ? '#e74c3c' : '#f39c12';
                        emoji = this.state === 'chasing' ? '😠' : '🚶';
                        break;
                    case 'dasher':
                        if (this.state === 'preparing') {
                            color = '#f1c40f';
                            emoji = '⚡';
                        } else if (this.isDashing) {
                            color = '#9b59b6';
                            emoji = '💨';
                        } else {
                            color = '#34495e';
                            emoji = '😴';
                        }
                        break;
                    case 'chaser':
                    default:
                        emoji = '👹';
                        break;
                }

                // 繪製敵人
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // 繪製表情
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(emoji, this.x + this.width/2, this.y + this.height/2 + 5);

                // 繪製狀態指示器
                if (this.type === 'dasher' && this.state === 'preparing') {
                    ctx.strokeStyle = '#f1c40f';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, 20, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }
        
        // 影子隊友數組
        let echoes = [];
        
        // 當前關卡配置
        let currentLevel = 1;
        
        // 敵人碰撞檢測
        function checkEnemyCollisions() {
            const level = getCurrentLevel();
            if (!level.enemies) return;

            level.enemies.forEach(enemy => {
                if (isColliding(player, enemy) && !player.isInvulnerable) {
                    player.isInvulnerable = true;
                    player.invulnerableTimer = Date.now();
                    resetPlayerPosition();
                }
            });

            // 更新無敵狀態
            if (player.isInvulnerable) {
                if (Date.now() - player.invulnerableTimer > 2000) { // 2秒無敵時間
                    player.isInvulnerable = false;
                }
            }
        }

        // 關卡設計
        const levels = {
            1: {
                tutorial: [
                    {x: 100, y: 150, color: '#FFFFFF', text: "使用 WASD 或方向鍵控制移動"},
                    {x: 300, y: 200, color: '#FFFFFF', text: "踩下紅色機關 ⚡"},  
                    {x: 500, y: 250, color: '#FFFFFF', text: "按 P 鍵創造影子"},  
                    {x: 700, y: 300, color: '#FFFFFF', text: "Ctrl+R 重新開始遊戲"},
                    {x: 900, y: 350, color: '#FFFF00', text: "Ctrl+1~5 跳關"}
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 200, y: 450, width: 150, height: 20, color: '#8B4513'},
                    {x: 500, y: 380, width: 100, height: 20, color: '#8B4513'},
                    {x: 700, y: 300, width: 120, height: 20, color: '#8B4513'},
                    {x: 900, y: 220, width: 100, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 250, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 550, y: 350, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 750, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'}
                ],
                movingPlatforms: [
                    {x: 400, y: 450, width: 80, height: 15, vx: 2, minX: 350, maxX: 450, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 150, y: 530, width: 40, height: 20, bounceForce: 20, color: '#f39c12'}
                ],
                goal: {x: 1050, y: 170, width: 40, height: 40, color: '#27ae60'}
            },
            2: {
                enemies: [
                    new Enemy(300, 500, 25, 25, 1, 'patrol')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 100, y: 480, width: 80, height: 20, color: '#8B4513'},
                    {x: 300, y: 420, width: 80, height: 20, color: '#8B4513'},
                    {x: 500, y: 360, width: 80, height: 20, color: '#8B4513'},
                    {x: 700, y: 300, width: 80, height: 20, color: '#8B4513'},
                    {x: 900, y: 240, width: 80, height: 20, color: '#8B4513'},
                    {x: 1100, y: 180, width: 80, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 130, y: 450, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 330, y: 390, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 530, y: 330, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 730, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'}
                ],
                movingPlatforms: [
                    {x: 200, y: 350, width: 60, height: 15, vx: 1.5, minX: 180, maxX: 280, color: '#9b59b6'},
                    {x: 800, y: 200, width: 60, height: 15, vx: -2, minX: 750, maxX: 850, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 450, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 650, y: 530, width: 40, height: 20, bounceForce: 22, color: '#f39c12'}
                ],
                goal: {x: 1120, y: 140, width: 40, height: 40, color: '#27ae60'}
            },
            3: {
                enemies: [
                    new Enemy(200, 500, 25, 25, 1, 'chaser'),
                    new Enemy(600, 500, 25, 25, 1, 'dasher')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 100, y: 450, width: 100, height: 20, color: '#8B4513'},
                    {x: 300, y: 350, width: 100, height: 20, color: '#8B4513'},
                    {x: 500, y: 250, width: 100, height: 20, color: '#8B4513'},
                    {x: 700, y: 200, width: 100, height: 20, color: '#8B4513'},
                    {x: 900, y: 150, width: 100, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 120, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 320, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 520, y: 220, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 720, y: 170, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]}
                ],
                movingPlatforms: [
                    {x: 200, y: 400, width: 60, height: 15, vx: 2, minX: 150, maxX: 250, color: '#9b59b6'},
                    {x: 400, y: 300, width: 60, height: 15, vx: 2, minX: 350, maxX: 450, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 150, y: 530, width: 40, height: 20, bounceForce: 22, color: '#f39c12'}
                ],
                goal: {x: 950, y: 100, width: 40, height: 40, color: '#27ae60'}
            },
            4: {
                enemies: [
                    new Enemy(300, 500, 25, 25, 1.2, 'patrol'),
                    new Enemy(600, 500, 25, 25, 1.2, 'dasher'),
                    new Enemy(900, 500, 25, 25, 1.2, 'chaser')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 150, y: 450, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 400, width: 80, height: 20, color: '#8B4513'},
                    {x: 650, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 900, y: 300, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 200, width: 400, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 170, y: 420, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 420, y: 370, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 670, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 920, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]},
                    {x: 585, y: 170, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [3]}
                ],
                movingPlatforms: [
                    {x: 300, y: 350, width: 60, height: 15, vx: 3, minX: 250, maxX: 350, color: '#9b59b6'},
                    {x: 550, y: 300, width: 60, height: 15, vx: -3, minX: 500, maxX: 600, color: '#9b59b6'},
                    {x: 800, y: 250, width: 60, height: 15, vx: 3, minX: 750, maxX: 850, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 200, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 450, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 700, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'}
                ],
                goal: {x: 580, y: 120, width: 40, height: 40, color: '#27ae60'}
            },
            5: {
                enemies: [
                    new Enemy(600, 450, 50, 50, 0.5, 'patrol'),
                    new Enemy(800, 450, 20, 30, 3, 'dasher'),
                    new Enemy(600, 600, 20, 20, 1.75, 'chaser'),
                    new Enemy(400, 450, 20, 30, 3, 'dasher')
                ],
                platforms: [
                    {x: 0, y: 550, width: 1200, height: 50, color: '#8B4513'},
                    {x: 200, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 400, y: 300, width: 70, height: 20, color: '#8B4513'},
                    {x: 600, y: 250, width: 60, height: 20, color: '#8B4513'},
                    {x: 800, y: 300, width: 70, height: 20, color: '#8B4513'},
                    {x: 1000, y: 350, width: 80, height: 20, color: '#8B4513'},
                    {x: 600, y: 150, width: 200, height: 20, color: '#8B4513'}
                ],
                switches: [
                    {x: 215, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure'},
                    {x: 415, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [0]},
                    {x: 615, y: 220, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [1]},
                    {x: 815, y: 270, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [2]},
                    {x: 1015, y: 320, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [3]},
                    {x: 600, y: 120, width: 30, height: 30, activated: false, color: '#e74c3c', type: 'pressure', required: [4]}
                ],
                movingPlatforms: [
                    {x: 200, y: 420, width: 60, height: 15, vx: 2, minX: 180, maxX: 280, color: '#9b59b6'},
                    {x: 400, y: 370, width: 60, height: 15, vx: -2, minX: 380, maxX: 480, color: '#9b59b6'},
                    {x: 600, y: 320, width: 60, height: 15, vx: 2, minX: 580, maxX: 680, color: '#9b59b6'},
                    {x: 800, y: 270, width: 60, height: 15, vx: -2, minX: 780, maxX: 880, color: '#9b59b6'}
                ],
                bouncePads: [
                    {x: 600, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 550, y: 230, width: 40, height: 20, bounceForce: 15, color: '#f39c12'},
                    {x: 250, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'},
                    {x: 950, y: 530, width: 40, height: 20, bounceForce: 25, color: '#f39c12'}
                ],
                goal: {x: 580, y: 70, width: 40, height: 40, color: '#27ae60'}
            }
        };
        
        // 獲取當前關卡
        function getCurrentLevel() {
            return levels[currentLevel] || levels[1];
        }
        
        // 重力
        const gravity = 0.8;
        
        // 開始遊戲
        function startGame() {
            const startScreen = document.getElementById('startScreen');
            startScreen.style.display = 'none';
            // 初始化音效系統
            initAudio();
            // 初始化遊戲
            initGame();
        }

        function initGame() {
            resetGame();
            resetPlayerPosition();
            gameState.isRoundActive = true;
        }

        // 音效系統
        const audio = {
            bgm: new Audio('assets/bgm.mp3'),
            switch: new Audio('assets/switch.mp3'),
            jump: new Audio('assets/jump.mp3'),
            shift: new Audio('assets/shift.mp3'),
            tada: new Audio('asests/tada.mp3'),
            final: new Audio('assets/final.mp3')
        };

        function initAudio() {
            audio.bgm.loop = true;
            audio.bgm.volume = 0.5;
            // 預設開啟音樂
            audio.bgm.play();
            document.getElementById('bgmBtn').textContent = '音樂：開';
        }

        function toggleBGM() {
            const btn = document.getElementById('bgmBtn');
            if (audio.bgm.paused) {
                audio.bgm.play();
                btn.textContent = '音樂：開';
            } else {
                audio.bgm.pause();
                btn.textContent = '音樂：關';
            }
        }

        // 速度控制
        const speeds = {
            slow: 3,
            normal: 5,
            fast: 7
        };

        function setSpeed(speedType) {
            player.speed = speeds[speedType];
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.style.background = '#333';
            });
            event.target.style.background = '#27ae60';
        }

        // 鍵盤輸入
        const keys = {
            left: false,
            right: false,
            up: false
        };
        
        // 事件監聽
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    keys.left = true;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = true;
                    break;
                case 'w':
                case 'arrowup':
                    if (!keys.up) {  // 只在首次按下時設置
                        keys.up = true;
                        if (player.onGround) {
                            player.vy = -player.jumpPower;
                            player.onGround = false;
                            audio.jump.play();
                        }
                    }
                    break;
                case 'p':
                    if (audio.shift) audio.shift.play();
                    e.preventDefault();
                    startNewRound();
                    break;
                case 'r':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        resetGame();
                    }
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                    // 偷跳關功能
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const targetLevel = parseInt(e.key);
                        if (targetLevel >= 1 && targetLevel <= 5) {
                            jumpToLevel(targetLevel);
                        }
                    }
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'a':
                case 'arrowleft':
                    keys.left = false;
                    break;
                case 'd':
                case 'arrowright':
                    keys.right = false;
                    break;
                case 'w':
                case 'arrowup':
                    keys.up = false;
                    break;
            }
        });
        
        // 更新玩家
        function updatePlayer() {
            if (!gameState.isRoundActive) return;
            
            // 檢查回合時間限制
            const roundTime = Date.now() - gameState.roundStartTime;
            if (roundTime > ROUND_TIME_LIMIT) {
                startNewRound();
                return;
            }
            
            // 記錄當前狀態
            const currentTime = Date.now() - gameState.roundStartTime;
            player.recording.push({
                time: currentTime,
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                action: getPlayerAction()
            });
            
            // 水平移動
            if (keys.left) {
                player.vx = -player.speed;
            } else if (keys.right) {
                player.vx = player.speed;
            } else {
                player.vx *= 0.8; // 摩擦力
            }
            
            // 重力
            player.vy += gravity;
            
            // 更新位置
            player.x += player.vx;
            player.y += player.vy;
            
            // 邊界檢查
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            // 碰撞檢測
            player.onGround = false;
            checkCollisions(player);
            
            // 檢查目標（只有在所有機關都激活時才能過關）
            if (isColliding(player, getCurrentLevel().goal) && allSwitchesActivated()) {
                gameState.goalReached = true;
                gameState.isRoundActive = false;
                showGoalMessage();
            }
            
            // 掉落重置
            if (player.y > canvas.height) {
                resetPlayerPosition();
            }
        }
        
        // 更新影子
        function updateEchoes() {
            const currentTime = Date.now() - gameState.roundStartTime;
            
            echoes.forEach(echo => {
                // 根據記錄更新影子位置
                for (let i = 0; i < echo.recording.length; i++) {
                    const record = echo.recording[i];
                    if (record.time <= currentTime) {
                        echo.x = record.x;
                        echo.y = record.y;
                        echo.vx = record.vx;
                        echo.vy = record.vy;
                        echo.currentAction = record.action;
                    } else {
                        break;
                    }
                }
                
                // 影子重力和碰撞
                echo.vy += gravity;
                echo.y += echo.vy;
                echo.onGround = false;
                checkCollisions(echo);
                
                if (echo.y > canvas.height) {
                    echo.x = 50;
                    echo.y = 400;
                    echo.vx = 0;
                    echo.vy = 0;
                }
            });
        }
        
        // 更新移動平台
        function updateMovingPlatforms() {
            const level = getCurrentLevel();
            if (!level.movingPlatforms) return;
            
            level.movingPlatforms.forEach(platform => {
                platform.x += platform.vx;
                if (platform.x <= platform.minX || platform.x >= platform.maxX) {
                    platform.vx = -platform.vx;
                }
            });
        }
        
        // 檢查碰撞
        function checkCollisions(entity) {
            const level = getCurrentLevel();
            
            // 檢查普通平台
            level.platforms.forEach(platform => {
                if (isColliding(entity, platform)) {
                    if (entity.vy > 0 && entity.y < platform.y) {
                        entity.y = platform.y - entity.height;
                        entity.vy = 0;
                        entity.onGround = true;
                    }
                }
            });
            
            // 檢查移動平台
            if (level.movingPlatforms) {
                level.movingPlatforms.forEach(platform => {
                    if (isColliding(entity, platform)) {
                        if (entity.vy > 0 && entity.y < platform.y) {
                            entity.y = platform.y - entity.height;
                            entity.vy = 0;
                            entity.onGround = true;
                            // 平台帶動效果
                            entity.x += platform.vx;
                        }
                    }
                });
            }
            
            // 檢查彈跳板
            if (level.bouncePads) {
                level.bouncePads.forEach(pad => {
                    if (isColliding(entity, pad) && entity.vy > 0) {
                        entity.vy = -pad.bounceForce;
                        entity.onGround = false;
                    }
                });
            }
        }
        
        // 碰撞檢測
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // 檢查機關激活
        function checkSwitchActivation() {
            const level = getCurrentLevel();
            
            level.switches.forEach((sw, index) => {
                // 檢查前置條件
                if (sw.required && sw.required.length > 0) {
                    const prerequisitesMet = sw.required.every(reqIndex => 
                        level.switches[reqIndex].activated
                    );
                    if (!prerequisitesMet) {
                        sw.activated = false;
                        return;
                    }
                }

                let activated = false;
                
                // 檢查玩家
                if (isColliding(player, sw)) {
                    activated = true;
                }
                
                // 檢查影子
                echoes.forEach(echo => {
                    if (isColliding(echo, sw)) {
                        activated = true;
                    }
                });
                
                if (activated && !sw.activated) {
                    audio.switch.play();
                }
                sw.activated = activated;
            });
        }
        
        // 檢查所有機關是否都激活
        function allSwitchesActivated() {
            const level = getCurrentLevel();
            return level.switches.every(sw => sw.activated);
        }
        
        // 獲取玩家動作
        function getPlayerAction() {
            if (keys.left) return 'left';
            if (keys.right) return 'right';
            if (keys.up) return 'jump';
            return 'idle';
        }
        
        // 重置玩家位置
        function resetPlayerPosition() {
            player.x = 50;
            player.y = 400;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.wasJumping = false;
        }
        
        // 開始新回合
        function startNewRound() {
            // 保存當前回合的記錄（如果有動作記錄）
            if (player.recording.length > 10) { // 只有有意義的記錄才保存
                const newEcho = {
                    x: 50,
                    y: 400,
                    width: 30,
                    height: 30,
                    vx: 0,
                    vy: 0,
                    onGround: false,
                    color: `rgba(52, 152, 219, ${Math.max(0.3, 1 - echoes.length * 0.15)})`,
                    recording: [...player.recording],
                    currentAction: 'idle'
                };
                echoes.push(newEcho);
                
                // 限制影子數量
                if (echoes.length > MAX_ECHOES) {
                    echoes.shift(); // 移除最老的影子
                }
            }
            
            // 重置玩家
            resetPlayerPosition();
            player.recording = [];
            
            // 重置機關
            const level = getCurrentLevel();
            level.switches.forEach(sw => sw.activated = false);
            
            // 更新遊戲狀態
            gameState.round++;
            gameState.roundStartTime = Date.now();
            gameState.isRoundActive = true;
            gameState.goalReached = false;
            
            // 顯示回合資訊
            showRoundInfo();
            
            // 移除目標達成消息
            const goalMsg = document.querySelector('.goal-reached');
            if (goalMsg) goalMsg.remove();
        }
        
        // 顯示回合資訊
        function showRoundInfo() {
            const roundInfo = document.createElement('div');
            roundInfo.className = 'round-info';
            roundInfo.innerHTML = `
                回合 ${gameState.round}<br>
                影子數量: ${echoes.length}/${MAX_ECHOES}<br>
                <small>需要同時激活所有機關！</small>
            `;
            document.getElementById('gameContainer').appendChild(roundInfo);
            
            setTimeout(() => {
                roundInfo.remove();
            }, 2000);
        }
        
        // 重置整個遊戲
        function resetGame() {
            // 重置影子和玩家
            echoes = [];
            resetPlayerPosition();
            player.recording = [];
            
            // 只重置當前關卡的回合數和時間
            gameState.round = 1;
            gameState.levelStats[currentLevel].startTime = Date.now();
            gameState.roundStartTime = Date.now();
            gameState.isRoundActive = true;
            gameState.goalReached = false;
            gameState.showingRoundInfo = false;
            
            // 只重置當前關卡的機關
            const level = getCurrentLevel();
            if (level.switches) {
                level.switches.forEach(sw => sw.activated = false);
            }
            
            // 清除所有UI消息
            document.querySelectorAll('.goal-reached, .round-info, .game-complete').forEach(el => el.remove());
        }
        
        // 進入下一關
        function nextLevel() {
            if (levels[currentLevel + 1]) {
                // 保存當前關卡的統計
                gameState.levelStats[currentLevel].rounds = gameState.round;
                
                currentLevel++;
                gameState.level = currentLevel;
                
                // 初始化新關卡的統計
                gameState.levelStats[currentLevel].startTime = Date.now();
                gameState.round = 1;
                echoes = [];
                resetPlayerPosition();
                player.recording = [];
                
                // 重置當前關卡的機關
                const level = getCurrentLevel();
                level.switches.forEach(sw => sw.activated = false);
                
                // 更新遊戲狀態
                gameState.roundStartTime = Date.now();
                gameState.isRoundActive = true;
                gameState.goalReached = false;
                
                // 清除所有消息
                document.querySelectorAll('.goal-reached, .round-info').forEach(el => el.remove());
            }
        }
        
        // 跳到指定關卡
        function jumpToLevel(targetLevel) {
            if (targetLevel >= 1 && targetLevel <= 5) {
                currentLevel = targetLevel;
                gameState.level = targetLevel;
                
                // 重置當前關卡
                gameState.round = 1;
                gameState.levelStats[currentLevel].startTime = Date.now();
                gameState.roundStartTime = Date.now();
                
                // 清除影子和重置玩家
                echoes = [];
                resetPlayerPosition();
                player.recording = [];
                
                // 重置當前關卡的機關
                const level = getCurrentLevel();
                if (level.switches) {
                    level.switches.forEach(sw => sw.activated = false);
                }
                
                // 更新遊戲狀態
                gameState.isRoundActive = true;
                gameState.goalReached = false;
                gameState.showingRoundInfo = false;
                
                // 清除所有UI消息
                document.querySelectorAll('.goal-reached, .round-info, .game-complete').forEach(el => el.remove());
                
                // 顯示跳關消息
                showJumpMessage(targetLevel);
            }
        }
        
        // 顯示跳關消息
        function showJumpMessage(level) {
            const jumpMsg = document.createElement('div');
            jumpMsg.className = 'round-info';
            jumpMsg.innerHTML = `
                🚀 跳到關卡 ${level}！<br>
                <small>Ctrl+數字鍵可快速跳關</small>
            `;
            document.getElementById('gameContainer').appendChild(jumpMsg);
            
            setTimeout(() => {
                jumpMsg.remove();
            }, 2000);
        }
        
        // 顯示結算畫面
        function showGameComplete() {
            audio.final.play();
            const completionMsg = document.createElement('div');
            completionMsg.className = 'game-complete';
            
            // 計算所有關卡的總回合數和時間
            let totalRounds = 0;
            let totalTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            
            // 計算每關的統計數據
            let levelStats = [];
            for (let i = 1; i <= 5; i++) {
                const stats = gameState.levelStats[i];
                const rounds = i === currentLevel ? gameState.round : stats.rounds;
                totalRounds += rounds;
                
                const time = i === currentLevel ? 
                    Math.floor((Date.now() - stats.startTime) / 1000) :
                    (i < currentLevel ? 
                        Math.floor((gameState.levelStats[i + 1].startTime - stats.startTime) / 1000) : 0);
                
                levelStats.push(`
                    <p>🎯 關卡 ${i}: ${rounds} 回合，${time} 秒</p>
                `);
            }
            
            completionMsg.innerHTML = `
                <h2>🎮 遊戲通關！</h2>
                <div class="stats">
                    <p>🌟 總通關時間: ${totalTime} 秒</p>
                    <p>🔄 總回合數: ${totalRounds}</p>
                    <p>⚡ 平均每關回合: ${Math.round(totalRounds / 5)} 回合</p>
                    <p>⏱️ 平均每關時間: ${Math.round(totalTime / 5)} 秒</p>
                    <hr>
                    <h3>各關卡統計</h3>
                    ${levelStats.join('')}
                </div>
                <div class="rating">
                    ${getRating(totalTime, totalRounds)}
                </div>
                
            `;
            document.getElementById('gameContainer').appendChild(completionMsg);
        }

        // 根據表現評分
        function getRating(time, rounds) {
            let stars = 3;
            const avgTimePerLevel = time / 5;
            const avgRoundsPerLevel = rounds / 5;        
            if (time > 180) stars--; // 總時間超過3分鐘減一星
            if (rounds > 30) stars--; // 總回合超過30回合減一星
            return '⭐'.repeat(stars);
        }

        // 顯示目標達成消息
        function showGoalMessage() {
            audio.tada.play();
            const goalMsg = document.createElement('div');
            goalMsg.className = 'goal-reached';
            
            if (currentLevel === 5) {
                showGameComplete();
                return;
            }

            goalMsg.innerHTML = `
                🎉 關卡 ${currentLevel} 完成！<br>
                用了 ${gameState.round} 回合<br>
                <small>${levels[currentLevel + 1] ? '進入下一關' : '重新開始'}</small>
            `;
            document.getElementById('gameContainer').appendChild(goalMsg);
            
            // 3秒後自動進入下一關或重開
            setTimeout(() => {
                if (levels[currentLevel + 1]) {
                    nextLevel();
                } else {
                    resetGame();
                }
            }, 500);
        }
        
        // 繪製函數
        function draw() {
            // 清除畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const level = getCurrentLevel();
            
            // 繪製平台
            level.platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });
            
            // 繪製移動平台
            if (level.movingPlatforms) {
                level.movingPlatforms.forEach(platform => {
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // 移動平台標示
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('▶', platform.x + platform.width/2, platform.y + platform.height/2 + 4);
                });
            }
            
            // 繪製彈跳板
            if (level.bouncePads) {
                level.bouncePads.forEach(pad => {
                    ctx.fillStyle = pad.color;
                    ctx.fillRect(pad.x, pad.y, pad.width, pad.height);
                    
                    // 彈跳板標示
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('↑', pad.x + pad.width/2, pad.y + pad.height/2 + 5);
                });
            }
            
            // 繪製機關
            level.switches.forEach((sw, index) => {
                ctx.fillStyle = sw.activated ? '#2ecc71' : sw.color;
                ctx.fillRect(sw.x, sw.y, sw.width, sw.height);
                
                // 機關標示和編號
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(sw.activated ? '✓' : '⚡', sw.x + sw.width/2, sw.y + sw.height/2);
                ctx.font = '12px Arial';
                ctx.fillText(`#${index + 1}`, sw.x + sw.width/2, sw.y - 5);
            });
            
            // 繪製目標（根據機關狀態改變顏色）
            const allActivated = allSwitchesActivated();
            ctx.fillStyle = allActivated ? level.goal.color : '#95a5a6';
            ctx.fillRect(level.goal.x, level.goal.y, level.goal.width, level.goal.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(allActivated ? '🎯' : '🔒', level.goal.x + level.goal.width/2, level.goal.y + level.goal.height/2 + 7);
            
            // 繪製影子
            echoes.forEach((echo, index) => {
                ctx.fillStyle = echo.color;
                ctx.fillRect(echo.x, echo.y, echo.width, echo.height);
                
                // 影子編號
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(index + 1, echo.x + echo.width/2, echo.y + echo.height/2 + 4);
            });
            
            // 繪製玩家
            ctx.fillStyle = player.isInvulnerable ? 'rgba(231, 76, 60, 0.5)' : player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('👤', player.x + player.width/2, player.y + player.height/2 + 5);
            
            // 繪製教學文字
            if (currentLevel === 1 && level.tutorial) {
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                level.tutorial.forEach(tip => {
                    ctx.fillStyle = tip.color || '#FFFFFF';
                    ctx.fillText(tip.text, tip.x, tip.y);
                });
            }

            // 繪製敵人
            if (level.enemies) {
                level.enemies.forEach(enemy => {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    // 敵人表情
                    ctx.fillStyle = 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('👿', enemy.x + enemy.width/2, enemy.y + enemy.height/2 + 5);
                });
            }

            // 繪製回合時間條
            if (gameState.isRoundActive) {
                const roundTime = Date.now() - gameState.roundStartTime;
                const timePercent = Math.min(roundTime / ROUND_TIME_LIMIT, 1);
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(20, canvas.height - 30, canvas.width - 40, 10);
                
                ctx.fillStyle = timePercent > 0.8 ? '#e74c3c' : '#3498db';
                ctx.fillRect(20, canvas.height - 30, (canvas.width - 40) * timePercent, 10);
            }
        }
        
        // 更新UI
        function updateUI() {
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('echoCount').textContent = echoes.length;
            document.getElementById('totalTimer').textContent = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            document.getElementById('level').textContent = gameState.level;
        }
        
        // 更新敵人
        function updateEnemies() {
            const level = getCurrentLevel();
            if (!level.enemies) return;
            level.enemies.forEach(enemy => enemy.update());
        }

        // 主遊戲循環 - 固定60FPS
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const FRAME_INTERVAL = 1000 / TARGET_FPS;
        
        function gameLoop(currentTime) {
            if (currentTime - lastFrameTime >= FRAME_INTERVAL) {
                updatePlayer();
                updateEchoes();
                updateMovingPlatforms();
                updateEnemies();
                checkSwitchActivation();
                checkEnemyCollisions();
                draw();
                updateUI();
                lastFrameTime = currentTime;
            }
            requestAnimationFrame(gameLoop);
        }
        
        // 調整 Canvas 大小和遊戲元素比例
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const header = document.getElementById('gameHeader');
            const canvas = document.getElementById('gameCanvas');
            
            // 設置 canvas 的邏輯大小（遊戲內部坐標系統）
            const BASE_WIDTH = 1200;
            const BASE_HEIGHT = 600;
            
            // 獲取可用空間
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight - header.offsetHeight;
            
            // 計算縮放比例
            const scale = Math.min(
                availableWidth / BASE_WIDTH,
                availableHeight / BASE_HEIGHT
            );
            
            // 設置 canvas 的實際大小
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            
            // 設置 CSS 縮放
            canvas.style.width = `${BASE_WIDTH * scale}px`;
            canvas.style.height = `${BASE_HEIGHT * scale}px`;
            
            // 置中 canvas
            canvas.style.left = `${(availableWidth - BASE_WIDTH * scale) / 2}px`;
            
            // 更新繪圖上下文的轉換
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // 監聽視窗大小變化
        window.addEventListener('resize', resizeCanvas);
        
        // 初始化大小
        resizeCanvas();
        
        // 開始遊戲
        gameLoop(0);
    </script>
</body>
</html>